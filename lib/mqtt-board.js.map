{"version":3,"file":"mqtt-board.js","sources":["../node_modules/@babel/runtime-corejs2/core-js/array/is-array.js","../node_modules/@babel/runtime-corejs2/helpers/arrayWithoutHoles.js","../node_modules/@babel/runtime-corejs2/core-js/array/from.js","../node_modules/@babel/runtime-corejs2/core-js/is-iterable.js","../node_modules/@babel/runtime-corejs2/helpers/iterableToArray.js","../node_modules/@babel/runtime-corejs2/helpers/nonIterableSpread.js","../node_modules/@babel/runtime-corejs2/helpers/toConsumableArray.js","../node_modules/@babel/runtime-corejs2/core-js/promise.js","../node_modules/@babel/runtime-corejs2/helpers/asyncToGenerator.js","../node_modules/@babel/runtime-corejs2/core-js/object/define-property.js","../node_modules/@babel/runtime-corejs2/helpers/defineProperty.js","../src/boot/async-mqtt.js","../src/mixins/animate.js","../node_modules/@babel/runtime-corejs2/core-js/symbol/iterator.js","../node_modules/@babel/runtime-corejs2/core-js/symbol.js","../node_modules/@babel/runtime-corejs2/helpers/typeof.js","../src/mixins/validateTopic.js","../src/mixins/validateEntities.js","../src/mixins/defaults.js","../src/mixins/jsonTreeByMessages.js","../src/components/MqttClient.vue"],"sourcesContent":["module.exports = require(\"core-js/library/fn/array/is-array\");","var _Array$isArray = require(\"../core-js/array/is-array\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (_Array$isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nmodule.exports = _arrayWithoutHoles;","module.exports = require(\"core-js/library/fn/array/from\");","module.exports = require(\"core-js/library/fn/is-iterable\");","var _Array$from = require(\"../core-js/array/from\");\n\nvar _isIterable = require(\"../core-js/is-iterable\");\n\nfunction _iterableToArray(iter) {\n  if (_isIterable(Object(iter)) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return _Array$from(iter);\n}\n\nmodule.exports = _iterableToArray;","function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nmodule.exports = _nonIterableSpread;","var arrayWithoutHoles = require(\"./arrayWithoutHoles\");\n\nvar iterableToArray = require(\"./iterableToArray\");\n\nvar nonIterableSpread = require(\"./nonIterableSpread\");\n\nfunction _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();\n}\n\nmodule.exports = _toConsumableArray;","module.exports = require(\"core-js/library/fn/promise\");","var _Promise = require(\"../core-js/promise\");\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    _Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new _Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator;","module.exports = require(\"core-js/library/fn/object/define-property\");","var _Object$defineProperty = require(\"../core-js/object/define-property\");\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    _Object$defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","'use strict'\n/* todo: remove after accepting PR in mqtt package */\nlet mqtt = require('mqtt')\n\nlet ASYNC_METHODS = [\n  'publish',\n  'subscribe',\n  'unsubscribe',\n  'end'\n]\n\nlet SYNC_METHODS = [\n  'emit',\n  'addListener',\n  'on',\n  'once',\n  'removeListener',\n  'removeAllListeners',\n  'setMaxListeners',\n  'getMaxListeners',\n  'listeners',\n  'listenerCount'\n]\n\nexport default {\n  connect: connect,\n  AsyncClient: AsyncClient\n}\n\nfunction connect (brokerURL, opts) {\n  let client = mqtt.connect(brokerURL, opts)\n\n  let asyncClient = new AsyncClient(client)\n\n  return asyncClient\n}\n\nfunction AsyncClient (client) {\n  this._client = client\n}\n\nAsyncClient.prototype = {\n  set handleMessage (newHandler) {\n    this._client.handleMessage = newHandler\n  },\n  get handleMessage () {\n    return this._client.handleMessage\n  }\n}\n\nASYNC_METHODS.forEach(defineAsync)\nSYNC_METHODS.forEach(definePassthrough)\n\nfunction definePassthrough (name) {\n  AsyncClient.prototype[name] = function () {\n    let client = this._client\n    return client[name].apply(client, arguments)\n  }\n}\n\nfunction defineAsync (name) {\n  AsyncClient.prototype[name] = function asyncMethod () {\n    let client = this._client\n    let args = []\n    let length = arguments.length\n    let i = 0\n    for (i; i < length; i++) {\n      args.push(arguments[i])\n    }\n\n    return new Promise(function (resolve, reject) {\n      args.push(makeCallback(resolve, reject))\n      client[name].apply(client, args)\n    })\n  }\n}\n\nfunction makeCallback (resolve, reject) {\n  return function (err, data) {\n    if (err) {\n      reject(err)\n    } else resolve(data)\n  }\n}\n","import { uid } from 'quasar'\nconst linear = t => t\nlet ids = {}\n\nexport function start ({ name, duration = 300, to, from, apply, done, cancel, easing }) {\n  let id = name\n  const start = new Date()\n  if (id) {\n    stop(id)\n  } else {\n    id = uid()\n  }\n\n  const delta = easing || linear\n  const handler = () => {\n    let progress = ((new Date()) - start) / duration\n    if (progress > 1) { progress = 1 }\n    const newPos = from + (to - from) * delta(progress)\n    apply(newPos, progress)\n    if (progress === 1) {\n      delete ids[id]\n      done && done(newPos)\n      return\n    }\n    anim.last = {\n      pos: newPos,\n      progress\n    }\n    anim.timer = requestAnimationFrame(handler)\n  }\n  const anim = ids[id] = {\n    cancel,\n    timer: requestAnimationFrame(handler)\n  }\n  return id\n}\nexport function stop (id) {\n  if (!id) {\n    return\n  }\n  let anim = ids[id]\n  if (anim && anim.timer) {\n    cancelAnimationFrame(anim.timer)\n    anim.cancel && anim.cancel(anim.last)\n    delete ids[id]\n  }\n}\nexport default {\n  start,\n  stop\n}\n","module.exports = require(\"core-js/library/fn/symbol/iterator\");","module.exports = require(\"core-js/library/fn/symbol\");","var _Symbol$iterator = require(\"../core-js/symbol/iterator\");\n\nvar _Symbol = require(\"../core-js/symbol\");\n\nfunction _typeof2(obj) { if (typeof _Symbol === \"function\" && typeof _Symbol$iterator === \"symbol\") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof _Symbol === \"function\" && obj.constructor === _Symbol && obj !== _Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof2(obj); }\n\nfunction _typeof(obj) {\n  if (typeof _Symbol === \"function\" && _typeof2(_Symbol$iterator) === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return _typeof2(obj);\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof _Symbol === \"function\" && obj.constructor === _Symbol && obj !== _Symbol.prototype ? \"symbol\" : _typeof2(obj);\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","export default {\n  methods: {\n    validateTopic (topic) {\n      let parts = topic.split('/')\n\n      for (let i = 0; i < parts.length; i++) {\n        if (parts[i] === '+') {\n          continue\n        }\n\n        if (parts[i] === '#') {\n          // for Rule #2\n          return i === parts.length - 1\n        }\n\n        if (parts[i].indexOf('+') !== -1 || parts[i].indexOf('#') !== -1) {\n          return false\n        }\n      }\n\n      return true\n    }\n  }\n}\n","import isNil from 'lodash/isNil'\nlet schemas = {\n  publisher: {\n    topic: 'string',\n    payload: 'string',\n    options: {\n      qos: 'number',\n      retain: 'boolean',\n      dup: 'boolean',\n      properties: {\n        payloadFormatIndicator: 'boolean',\n        messageExpiryInterval: 'number',\n        topicAlias: 'number',\n        responseTopic: 'string',\n        correlationData: 'string',\n        userProperties: {},\n        contentType: 'string'\n      }\n    }\n  },\n  subscriber: {\n    topic: 'string',\n    mode: 'number',\n    options: {\n      qos: 'number',\n      nl: 'boolean',\n      rap: 'boolean',\n      rh: 'number',\n      properties: {\n        subscriptionIdentifier: 'number',\n        userProperties: {}\n      }\n    }\n  },\n  settings: {\n    clientId: 'string',\n    host: 'string',\n    keepalive: 'number',\n    protocolVersion: 'number',\n    clean: 'boolean',\n    username: 'string',\n    password: 'string',\n    properties: {\n      sessionExpiryInterval: 'number',\n      receiveMaximum: 'number',\n      maximumPacketSize: 'number',\n      topicAliasMaximum: 'number',\n      requestResponseInformation: 'boolean',\n      requestProblemInformation: 'boolean',\n      userProperties: {},\n      authenticationMethod: 'string',\n      authenticationData: 'string'\n    },\n    will: {\n      topic: 'string',\n      payload: 'string',\n      qos: 'number',\n      retain: 'boolean',\n      properties: {\n        willDelayInterval: 'number',\n        payloadFormatIndicator: 'boolean',\n        messageExpiryInterval: 'number',\n        contentType: 'string',\n        responseTopic: 'string',\n        correlationData: 'string',\n        userProperties: {}\n      }\n    }\n  },\n  entity: {\n    type: 'string',\n    index: 'number',\n    id: 'string'\n  }\n}\n\nexport default {\n  methods: {\n    validateObjectBySchema (object, schema) {\n      return Object.keys(schema).reduce((result, key) => {\n        if (object[key] !== undefined && object[key] !== null) {\n          let objectValueType = typeof object[key]\n          if (typeof schema[key] === 'object') {\n            result = result && this.validateObjectBySchema(object[key], schema[key])\n          } else if (objectValueType === schema[key]) {\n            result = result && true\n          } else {\n            result = result && false\n          }\n        }\n        return result\n      }, true)\n    },\n    validateEntity (entity) {\n      switch (entity.type) {\n        case 'publisher': {\n          return this.validatePublisher(entity.settings)\n        }\n        case 'subscriber': {\n          return this.validateSubscriber(entity.settings)\n        }\n        default: {\n          return false\n        }\n      }\n    },\n    validateSettings (settings) {\n      return this.validateObjectBySchema(settings, schemas['settings']) &&\n        !!settings.clientId &&\n        !!settings.host &&\n        (\n          isNil(settings.keepalive) ||\n          (settings.keepalive >= 0 && settings.keepalive <= 0xffff)\n        ) &&\n        (\n          !settings.will || (!!settings.will && (\n            (!!settings.will.topic && !!settings.will.payload) ||\n            (!settings.will.topic && !settings.will.payload)\n          ))\n        ) &&\n        (!settings.properties ||\n          (\n            !!settings.properties && (\n              (isNil(settings.properties.sessionExpiryInterval) || (settings.properties.sessionExpiryInterval >= 0 && settings.properties.sessionExpiryInterval <= 0xffffffff)) &&\n              (isNil(settings.properties.receiveMaximum) || (settings.properties.receiveMaximum > 0 && settings.properties.receiveMaximum <= 0xffff)) &&\n              (isNil(settings.properties.maximumPacketSize) || (settings.properties.maximumPacketSize > 0 && settings.properties.maximumPacketSize <= 0xffffffff)) &&\n              (isNil(settings.properties.topicAliasMaximum) || (settings.properties.topicAliasMaximum >= 0 && settings.properties.topicAliasMaximum <= 0xffff))\n            )\n          )\n        )\n    },\n    validatePublisher (publisher) {\n      return this.validateObjectBySchema(publisher, schemas['publisher']) &&\n      !!publisher.topic && !!publisher.options &&\n      (!publisher.options.properties ||\n        (\n          !!publisher.options.properties &&\n          (isNil(publisher.options.properties.messageExpiryInterval) || (publisher.options.properties.messageExpiryInterval >= 0 && publisher.options.properties.messageExpiryInterval <= 0xffffffff)) &&\n          (isNil(publisher.options.properties.topicAlias) || (publisher.options.properties.topicAlias > 0 && publisher.options.properties.topicAlias <= 0xffff))\n        )\n      )\n    },\n    validateSubscriber (subscriber) {\n      return this.validateObjectBySchema(subscriber, schemas['subscriber']) &&\n        !!subscriber.topic && !!subscriber.options &&\n        (!subscriber.options.properties ||\n          (\n            !!subscriber.options.properties &&\n            (isNil(subscriber.options.properties.subscriptionIdentifier) || (subscriber.options.properties.subscriptionIdentifier > 0 && subscriber.options.properties.subscriptionIdentifier <= 268435455))\n          )\n        )\n    },\n    validateEntityRecord (settings) {\n      return this.validateObjectBySchema(settings, schemas['entity'])\n    }\n  }\n}\n","let defaultSettings = {\n    clientId: `mqtt-board-${Math.random().toString(16).substr(2, 8)}`,\n    wsOptions: {\n      objectMode: false,\n      perMessageDeflate: true\n    },\n    host: 'wss://mqtt.flespi.io',\n    keepalive: 420,\n    protocolVersion: 5,\n    resubscribe: false,\n    clean: true,\n    username: 'FlespiToken XXXXXXXXXXXXXXXXXXX',\n    password: '',\n    properties: {\n      sessionExpiryInterval: undefined,\n      receiveMaximum: undefined,\n      maximumPacketSize: undefined,\n      topicAliasMaximum: undefined,\n      requestResponseInformation: false,\n      requestProblemInformation: false,\n      userProperties: undefined,\n      authenticationMethod: undefined,\n      authenticationData: undefined\n    },\n    will: {\n      topic: undefined,\n      payload: undefined,\n      qos: 0,\n      retain: false,\n      properties: {\n        willDelayInterval: undefined,\n        payloadFormatIndicator: false,\n        messageExpiryInterval: undefined,\n        contentType: undefined,\n        responseTopic: undefined,\n        correlationData: undefined,\n        userProperties: undefined\n      }\n    }\n  },\n  defaultSubscriber = {\n    topic: '#',\n    mode: 0,\n    treeField: '',\n    highlight: true,\n    options: {\n      qos: 0,\n      nl: false,\n      rap: false,\n      rh: 0,\n      properties: {\n        subscriptionIdentifier: undefined,\n        userProperties: undefined\n      }\n    },\n    unsubscribeProperties: {\n      userProperties: undefined\n    }\n  },\n  defaultPublisher = {\n    topic: 'my/topic',\n    payload: '{\"hello\": \"world\"}',\n    options: {\n      qos: 0,\n      retain: false,\n      dup: false,\n      properties: {\n        payloadFormatIndicator: undefined,\n        messageExpiryInterval: undefined,\n        topicAlias: undefined,\n        responseTopic: undefined,\n        correlationData: undefined,\n        userProperties: undefined,\n        contentType: undefined\n      }\n    }\n  }\nexport {\n  defaultSettings,\n  defaultSubscriber,\n  defaultPublisher\n}\n","import Vue from 'vue'\nfunction jsonTreeByMessages (messages, treeField, dest) {\n  function write (topic, payload, dest) {\n    let path = topic.split('/')\n    let currentNesting = dest\n    let currentTopic = ''\n    path.forEach((pathElement, pathIndex, path) => {\n      if (!currentNesting[pathElement]) {\n        Vue.set(currentNesting, pathElement, { children: undefined, topic: '', value: undefined })\n      }\n      if (pathIndex !== 0) {\n        currentTopic += '/'\n      }\n      currentTopic += `${pathElement}`\n      Vue.set(currentNesting[pathElement], 'topic', currentTopic)\n      if (pathIndex !== path.length - 1) {\n        if (!currentNesting[pathElement].children) {\n          Vue.set(currentNesting[pathElement], 'children', {})\n        }\n        currentNesting = currentNesting[pathElement].children\n      } else {\n        if (!currentNesting[pathElement].value) {\n          Vue.set(currentNesting[pathElement], 'value', {})\n        }\n        let valueByTreeField = payload.properties && payload.properties.userProperties && payload.properties.userProperties[treeField]\n          ? payload.properties.userProperties[treeField]\n          : ''\n        Vue.set(currentNesting[pathElement].value, valueByTreeField, JSON.stringify(payload))\n      }\n    })\n  }\n  function clear (topic, payload, dest) {\n    function getNesting (obj, path) {\n      let currentChildContainers = new Array(path.length).fill(undefined)\n      currentChildContainers[0] = obj\n      return path.reduce((nesting, pathElement, pathIndex, path) => {\n        let currentNesting = {\n          container: currentChildContainers[pathIndex] || null,\n          name: pathElement\n        }\n        currentChildContainers[pathIndex + 1] = currentNesting.container && currentNesting.container[pathElement] ? currentNesting.container[pathElement].children : null\n        return currentNesting\n      }, { container: obj, name: path[0] })\n    }\n    let path = topic.split('/')\n    new Array(path.length).fill('').forEach((_, index) => {\n      let nestingCount = path.length - index\n      let currentPath = path.slice(0, nestingCount)\n      let nesting = getNesting(dest, currentPath)\n      if (!nesting.container || !nesting.container[nesting.name]) { return false }\n      let valueByPath = nesting.container[nesting.name]\n      let hasChildren = valueByPath.children && !!Object.keys(valueByPath.children).length\n      if (valueByPath.value && index === 0) {\n        let valueByTreeField = payload.properties && payload.properties.userProperties && payload.properties.userProperties[treeField]\n          ? payload.properties.userProperties[treeField]\n          : ''\n        Vue.delete(valueByPath.value, valueByTreeField)\n        if (!Object.keys(valueByPath.value).length) {\n          Vue.set(valueByPath, 'value', undefined)\n        }\n      }\n      if (!hasChildren) {\n        Vue.set(valueByPath, 'children', undefined)\n        if (!valueByPath.value) {\n          Vue.delete(nesting.container, nesting.name)\n        }\n      }\n    })\n  }\n  function getAction (message) {\n    return typeof message.payload === 'string' && !message.payload.length ? clear : write\n  }\n  if (Array.isArray(messages)) {\n    messages.forEach(message => {\n      getAction(message)(message.topic, message, dest)\n    })\n  } else {\n    getAction(messages)(messages.topic, messages, dest)\n  }\n}\n\nexport default jsonTreeByMessages\n","<template>\n  <div style=\"position: absolute; bottom: 0; right: 0; top: 0; left: 0;\">\n    <flespi-topic ref=\"felspiModal\" @topic=\"(topic) => { addSubscriber(); subscribers[subscribers.length - 1].topic = topic }\"/>\n    <publisher-modal\n      v-if=\"republishMessage\"\n      ref=\"publisherModal\"\n      :message=\"republishMessage\"\n      :version=\"activeClient.config.protocolVersion\"\n      @publish=\"publishFreeMessage\"\n      @hide=\"republishMessage = null\"\n    />\n    <q-dialog\n      @show=\"showSettingsModalHandler\"\n      @hide=\"clearCurrentSettings\"\n      v-model='settingsModalModel'\n      class=\"mqtt-board-modal mqtt-board-settings-modal\"\n      :maximized=\"$q.platform.is.mobile\"\n    >\n      <q-card :style=\"{minWidth: $q.platform.is.mobile ? '100%' : '50vw'}\">\n        <q-card-section :class=\"{[`bg-${color}`]: true, 'text-white': !!color}\" class=\"q-pa-none\">\n          <q-toolbar :class=\"{[`bg-${color}`]: true, 'text-white': !!color}\">\n            <q-btn flat dense v-close-popup icon=\"keyboard_arrow_left\" @click=\"revertSettings\"/>\n            <q-toolbar-title>\n              Connection settings\n            </q-toolbar-title>\n          </q-toolbar>\n        </q-card-section>\n        <q-separator />\n        <q-card-section class=\"scroll\" :style=\"{ height: $q.platform.is.mobile ? 'calc(100% - 94px)' : '50vh'}\">\n          <div>\n            <q-input color=\"grey-9\" outlined v-model=\"currentSettings.clientName\" label=\"Client name\" class=\"q-mb-xs\"/>\n            <q-input color=\"grey-9\" outlined v-model=\"currentSettings.clientId\" label=\"Client ID\" :error=\"!currentSettings.clientId\" hide-bottom-space class=\"q-mb-xs\">\n              <q-btn slot=\"append\" color=\"grey-9\" icon=\"mdi-refresh\" @click=\"currentSettings.clientId = `mqtt-board-${Math.random().toString(16).substr(2, 8)}`\" flat round/>\n            </q-input>\n            <q-input color=\"grey-9\" outlined v-model=\"currentSettings.host\" label=\"Host\" :error=\"!currentSettings.host || (secure && currentSettings.host.indexOf('ws:') === 0)\" error-message=\"Host must be not empty and only over secured sockets\" hide-bottom-space class=\"q-mb-xs\"/>\n            <q-input color=\"grey-9\" outlined class=\"q-mb-xs\" hide-bottom-space v-model=\"currentSettings.keepalive\" type=\"number\" label=\"Keep alive\" :error=\"!isNil(currentSettings.keepalive) && (currentSettings.keepalive <= 0 || currentSettings.keepalive > 0xffff)\"/>\n            <q-select color=\"grey-9\" outlined class=\"q-mb-xs\" v-model=\"currentSettings.protocolVersion\" :options=\"[{label: '3.1.1', value: 4}, {label: '5.0', value: 5}]\" label=\"Version of MQTT\" hide-bottom-space options-selected-class=\"bg-grey-2 text-grey-9\"/>\n            <q-checkbox color=\"grey-9\" class=\"q-mt-sm q-mb-sm\" v-model=\"currentSettings.clean\" :label=\"currentSettings.protocolVersion === 5 ? 'Clean start' : 'Clean session'\"/>\n            <q-input color=\"grey-9\" outlined class=\"q-mb-xs\" hide-bottom-space v-model=\"currentSettings.username\" label=\"Username\">\n              <q-btn slot=\"append\" color=\"grey-9\" icon=\"mdi-login\" @click=\"flespiLoginHandler\" flat round v-if=\"currentSettings.host.indexOf('flespi') !== -1\"/>\n            </q-input>\n            <q-input color=\"grey-9\" outlined class=\"q-mb-xs\" hide-bottom-space v-model=\"currentSettings.password\" label=\"Password\"/>\n            <q-expansion-item class=\"q-mt-sm q-mb-sm bg-grey-2\" label=\"Properties\" v-if=\"currentSettings.protocolVersion === 5\">\n              <div class=\"q-px-md q-py-sm\">\n                <q-input\n                  color=\"grey-9\" outlined class=\"q-mb-xs\" hide-bottom-space type=\"number\" :min=\"0\" clearable\n                  v-model=\"currentSettings.properties.sessionExpiryInterval\"\n                  @clear=\"currentSettings.properties.sessionExpiryInterval = undefined\"\n                  label=\"Session expiry interval\"\n                  :error=\"!isNil(currentSettings.properties.sessionExpiryInterval) && (currentSettings.properties.sessionExpiryInterval < 0 || currentSettings.properties.sessionExpiryInterval > 0xffffffff)\"\n                />\n                <q-input\n                  color=\"grey-9\" type=\"number\" label=\"Receive maximum\" clearable outlined class=\"q-mb-xs\" hide-bottom-space\n                  v-model=\"currentSettings.properties.receiveMaximum\"\n                  @clear=\"currentSettings.properties.receiveMaximum = undefined\"\n                  :error=\"!isNil(currentSettings.properties.receiveMaximum) && (currentSettings.properties.receiveMaximum <= 0 || currentSettings.properties.receiveMaximum > 0xffff)\"\n                />\n                <q-input\n                  color=\"grey-9\" type=\"number\" label=\"Maximum packet size\" clearable outlined class=\"q-mb-xs\" hide-bottom-space\n                  v-model=\"currentSettings.properties.maximumPacketSize\"\n                  @clear=\"currentSettings.properties.maximumPacketSize = undefined\"\n                  :error=\"!isNil(currentSettings.properties.maximumPacketSize) && (currentSettings.properties.maximumPacketSize <= 0 || currentSettings.properties.maximumPacketSize > 0xffffffff)\"\n                />\n                <q-input\n                  color=\"grey-9\" type=\"number\" label=\"Topic alias maximum\" clearable outlined class=\"q-mb-xs\" hide-bottom-space\n                  v-model=\"currentSettings.properties.topicAliasMaximum\"\n                  :error=\"!isNil(currentSettings.properties.topicAliasMaximum) && (currentSettings.properties.topicAliasMaximum < 0 || currentSettings.properties.topicAliasMaximum > 0xffff)\"\n                />\n                <q-checkbox style=\"display: flex;\" color=\"grey-9\" class=\"q-mt-sm q-mb-sm\" v-model=\"currentSettings.properties.requestResponseInformation\" label=\"Request-Response information\"/>\n                <q-checkbox style=\"display: flex;\" color=\"grey-9\" class=\"q-mt-sm q-mb-sm\" v-model=\"currentSettings.properties.requestProblemInformation\" label=\"Request problem information\"/>\n                <div class=\"q-mb-sm\">\n                  <div class=\"q-mt-md\">User Properties</div>\n                  <div>\n                    <q-list v-if=\"currentSettings.properties.userProperties\" bordered class=\"q-mb-xs\">\n                      <q-item v-for=\"(value, name) in currentSettings.properties.userProperties\" :key=\"`${name}: ${value}`\" style=\"min-height: 17px;\">\n                        <q-icon class=\"q-mr-sm cursor-pointer\" size='1rem' @click.native=\"removeConnectUserProperty(name)\" name=\"mdi-close-circle\"/>\n                        <span>{{`${name}: ${value}`}}</span>\n                      </q-item>\n                    </q-list>\n                    <q-input color=\"grey-9\" v-model=\"connectUserProperty.name\" label=\"User property name\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                    <q-input color=\"grey-9\" v-model=\"connectUserProperty.value\" label=\"User property value\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                    <q-btn style=\"width: 100%\" class=\"q-mt-sm\" color=\"grey-9\" @click=\"addUserProperty\">Add</q-btn>\n                  </div>\n                </div>\n                <q-input color=\"grey-9\" v-model=\"currentSettings.properties.authenticationMethod\" label=\"Authentication method\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                <q-input color=\"grey-9\" v-model=\"currentSettings.properties.authenticationData\" type=\"textarea\" label=\"Authentication data\" outlined class=\"q-mb-xs q-textarea--fix\" hide-bottom-space autogrow/>\n              </div>\n            </q-expansion-item>\n            <q-expansion-item class=\"q-mt-sm q-mb-sm bg-grey-2\" label=\"Will\">\n              <div class=\"q-px-md q-py-sm\">\n                <q-input color=\"grey-9\" v-model=\"currentSettings.will.topic\" :error=\"!this.currentSettings.will.topic && !!this.currentSettings.will.payload\" label=\"Will topic\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                <q-input color=\"grey-9\" v-model=\"currentSettings.will.payload\" :error=\"!!this.currentSettings.will.topic && !this.currentSettings.will.payload\" type=\"textarea\" label=\"Will payload\" outlined class=\"q-mb-xs q-textarea--fix\" hide-bottom-space autogrow/>\n                <div class=\"q-my-sm\">\n                  QoS\n                  <q-btn-toggle flat rounded toggle-text-color=\"grey-9\" text-color=\"grey-6\" class=\"q-ml-sm\" v-model=\"currentSettings.will.qos\" :options=\"[{label: '0', value: 0},{label: '1', value: 1},{label: '2', value: 2}]\"/>\n                </div>\n                <q-checkbox color=\"grey-9\" class=\"q-mt-sm q-mb-sm\" v-model=\"currentSettings.will.retain\" label=\"Will retain\" />\n                <q-expansion-item class=\"bg-grey-4\" label=\"Will properties\" v-if=\"currentSettings.protocolVersion === 5\">\n                  <div class=\"q-px-md q-py-sm\">\n                    <q-input\n                      color=\"grey-9\" outlined clearable class=\"q-mb-xs\" hide-bottom-space type=\"number\" label=\"Will delay interval\"\n                      v-model=\"currentSettings.will.properties.willDelayInterval\"\n                      @clear=\"currentSettings.will.properties.willDelayInterval = undefined\"\n                    />\n                    <q-checkbox color=\"grey-9\" class=\"q-mt-sm q-mb-sm\" v-model=\"currentSettings.will.properties.payloadFormatIndicator\" label=\"Payload format indicator\"/>\n                    <q-input\n                      color=\"grey-9\" type=\"number\" label=\"Message expiry interval\" clearable outlined class=\"q-mb-xs\" hide-bottom-space\n                      v-model=\"currentSettings.will.properties.messageExpiryInterval\"\n                      @clear=\"currentSettings.will.properties.messageExpiryInterval = undefined\"\n                    />\n                    <q-input color=\"grey-9\" v-model=\"currentSettings.will.properties.contentType\" label=\"Content type\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                    <q-input color=\"grey-9\" v-model=\"currentSettings.will.properties.responseTopic\" label=\"Response topic\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                    <q-input color=\"grey-9\" v-model=\"currentSettings.will.properties.correlationData\" type=\"textarea\" label=\"Correlation data\" outlined class=\"q-mb-xs q-textarea--fix\" hide-bottom-space autogrow />\n                    <div>\n                      <div class=\"q-mt-md\">Will user properties</div>\n                      <div>\n                        <q-list style=\"border-color: #b7b7b7;\" v-if=\"currentSettings.will.properties.userProperties\" class=\"q-mb-xs\">\n                          <q-item v-for=\"(value, name) in currentSettings.will.properties.userProperties\" :key=\"`${name}: ${value}`\" style=\"min-height: 17px;\">\n                            <q-icon class=\"q-mr-sm cursor-pointer\" size='1rem' @click.native=\"removeWillConnectUserProperty(name)\" name=\"mdi-close-circle\"/>\n                            <span>{{`${name}: ${value}`}}</span>\n                          </q-item>\n                        </q-list>\n                        <q-input color=\"grey-9\" v-model=\"willConnectUserProperty.name\" label=\"Will user property name\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                        <q-input color=\"grey-9\" v-model=\"willConnectUserProperty.value\"  label=\"Will user property value\" outlined class=\"q-mb-xs\" hide-bottom-space/>\n                        <q-btn style=\"width: 100%\" class=\"q-mt-sm\" color=\"grey-9\" @click=\"addWillUserProperty\">Add</q-btn>\n                      </div>\n                    </div>\n                  </div>\n                </q-expansion-item>\n              </div>\n            </q-expansion-item>\n          </div>\n        </q-card-section>\n        <q-separator />\n        <q-card-actions align=\"right\" :class=\"{[`bg-${color}`]: true, 'text-white': !!color}\">\n          <q-btn flat dense v-close-popup class=\"q-mr-sm\" @click=\"revertSettings\">Close</q-btn>\n          <q-btn flat dense :disable=\"!isCurrentSettingsValid\" @click=\"saveSettingsHandler\">Save</q-btn>\n        </q-card-actions>\n      </q-card>\n    </q-dialog>\n    <q-btn fab v-if=\"!activeClient\" @click.native=\"addClientHandler\" icon=\"mdi-plus\" :color=\"accentColor\" style=\"position: absolute; right: 16px; top: 21px; z-index: 2;\"/>\n    <q-toolbar :class=\"{[`bg-${color}`]: true, 'text-white': !!color}\"  style=\"position: absolute; z-index: 1\">\n      <q-btn round v-if=\"activeClient\" flat dense icon=\"mdi-close\" @click=\"clearActiveClient\"/>\n      <q-toolbar-title>\n        <img v-if=\"!activeClient && whiteLabel === ''\" src=\"statics/mqttboard.png\" alt=\"MQTT Board\" style=\"height: 30px\">\n        <span v-if=\"activeClient\">\n          {{`${activeClient.config.clientName || activeClient.config.clientId}`}}\n          <q-tooltip v-if=\"activeClient.config.clientName\">{{`${activeClient.config.clientId}`}}</q-tooltip>\n        </span>\n        <span v-else>\n          {{whiteLabel || 'MQTT Board'}}\n        </span>\n        <sup v-if=\"activeClient && $q.platform.is.desktop\" style=\"border-radius: 5px;font-size: .6rem; padding: 2px; min-width: 15px; top: 5px;\" :class=\"[`bg-${activeClient.status ? 'green': 'red'}`]\" class=\"absolute\">{{activeClient.status ? 'online': 'offline'}}</sup>\n        <sub v-if=\"activeClient && $q.platform.is.desktop && activeClient.cid\" style=\"border-radius: 5px;font-size: .7rem; padding: 2px;\" title=\"cid\">{{activeClient.cid}}</sub>\n        <sup v-if=\"!activeClient && whiteLabel === ''\" style=\"position: relative; font-size: .9rem; padding-left: 4px\">{{version}}</sup>\n      </q-toolbar-title>\n      <q-btn\n        class=\"q-mr-md\" dark color=\"white\" flat round\n        :icon=\"unresolvedModel ? 'mdi-alert-circle' : 'mdi-alert-circle-outline'\"\n        @click=\"changeUnresolvedStatus(!unresolvedModel)\"\n        v-if=\"activeClient && !!activeClient.notResolvedFlagInit\"\n      >\n        <q-tooltip>Unresolved</q-tooltip>\n      </q-btn>\n      <q-btn v-if=\"activeClient\" flat round class=\"q-mr-sm\" :color=\"logsModel ? 'blue-5' : 'white'\" icon=\"mdi-script\" @click=\"changeLogsStatus(!logsModel)\">\n        <q-tooltip class=\"gt-sm\">Logs</q-tooltip>\n      </q-btn>\n      <q-btn round flat dark v-if=\"activeClient\" icon=\"mdi-settings\" @click.stop=\"editClientHandler(activeClient.id)\"/>\n      <q-btn round flat v-if=\"activeClient\" icon=\"mdi-plus\">\n        <q-menu anchor=\"bottom right\" self=\"top right\">\n          <q-list>\n            <q-item-label header>Add pane</q-item-label>\n            <q-item v-close-popup @click.native=\"addPublisher\" clickable v-ripple>\n              <q-item-section avatar><q-icon name=\"mdi-publish\" /></q-item-section>\n              <q-item-section><q-item-label>Publisher</q-item-label></q-item-section>\n            </q-item>\n            <q-item v-close-popup @click.native=\"addSubscriber\" clickable v-ripple>\n              <q-item-section avatar><q-icon name=\"mdi-arrow-down-bold\" /></q-item-section>\n              <q-item-section><q-item-label>Subscriber</q-item-label></q-item-section>\n            </q-item>\n            <q-item v-if=\"activeClient && activeClient.config.host.indexOf('flespi') !== -1\" v-close-popup @click.native=\"$refs.felspiModal.open()\" clickable v-ripple>\n              <q-item-section avatar><q-icon name=\"mdi-star-outline\" /></q-item-section>\n              <q-item-section><q-item-label>Flespi subscriber</q-item-label></q-item-section>\n            </q-item>\n          </q-list>\n        </q-menu>\n      </q-btn>\n      <q-btn v-if=\"!activeClient && !whiteLabel\" dense flat @click=\"openURL('https://github.com/flespi-software/MQTT-Board')\" color=\"white\" icon=\"mdi-github-circle\" style=\"margin-right: 60px\" :label=\"$q.platform.is.mobile ? '' : 'Fork me!'\"/>\n    </q-toolbar>\n    <div v-if=\"!activeClient\" class=\"absolute scroll\" style=\"top:50px; left: 0; right: 0; bottom: 0;\">\n      <div v-if=\"Object.keys(clients).length\" class=\"mqtt-clients row q-pt-md\">\n        <div class=\"client__item q-pt-md q-px-md cursor-pointer col-xl-3 col-md-4 col-sm-6 col-xs-12\" v-for=\"(client, index) in clients\" :key=\"index\">\n          <q-card :class=\"{'bg-red-2': !statuses[index], 'bg-green-2': statuses[index]}\" @click.native=\"setActiveClient(index)\">\n            <q-card-section class=\"q-py-sm\">\n              <div class=\"ellipsis q-mb-xs\" style=\"font-size: 18px; line-height: 18px; min-height: 18px;\">{{client.config.clientName || client.config.clientId}}</div>\n              <div class=\"ellipsis text-grey-9\" style=\"font-size: 14px; line-height: 14px; min-height: 14px;\">{{client.config.clientName ? client.config.clientId : ''}}</div>\n            </q-card-section>\n            <q-card-section class=\"ellipsis\">\n              <span class=\"text-grey-9\">{{client.config.host}}</span>\n            </q-card-section>\n            <q-separator />\n            <q-card-actions align=\"right\">\n              <q-btn round flat v-if=\"client.client\" size=\".7rem\" icon=\"mdi-stop\" :loading=\"!!client.client && !statuses[index] && client.inited\" @click.stop=\"disconnectClientHandler(index)\">\n                <q-tooltip>Deactivate client</q-tooltip>\n              </q-btn>\n              <q-btn round flat v-else size=\".7rem\" icon=\"mdi-play\" @click.stop=\"connectClientHandler(index)\">\n                <q-tooltip>Activate client</q-tooltip>\n              </q-btn>\n              <q-btn round flat size=\".7rem\" icon=\"mdi-settings\" @click.stop=\"editClientHandler(index)\"/>\n              <q-btn round flat size=\".7rem\" icon=\"mdi-delete\" @click.stop=\"deleteClientHandler(index)\"/>\n            </q-card-actions>\n          </q-card>\n        </div>\n      </div>\n      <div v-else class=\"text-center q-mt-lg text-grey-9 text-weight-bold\" style=\"font-size: 2.5rem;\">\n        <div>No clients</div>\n        <q-btn v-if=\"!activeClient\" @click.native=\"addClientHandler\">Create client</q-btn>\n      </div>\n    </div>\n    <div ref=\"wrapper\" v-touch-swipe.horizontal=\"swipeHandler\" class=\"no-wrap row client__wrapper\" v-else-if=\"entities.length\">\n      <template v-for=\"(entity, index) in entities\">\n        <publisher\n          :class='[`col-xl-${entities.length < 4 ? 12 / entities.length : 3}`]'\n          v-if=\"entity.type === 'publisher'\"\n          :key=\"`publ${entity.id}`\"\n          :value=\"publishers[entity.index]\"\n          @input=\"(val) => { inputPublisher(entity.index, val) }\"\n          :version=\"activeClient.config.protocolVersion\"\n          @remove=\"removePublisher(entity.index)\"\n          @publish=\"publishMessageHandler(activeClient.id, entity.index)\"\n        />\n        <subscriber\n          :class='[`col-xl-${entities.length < 4 ? 12 / entities.length : 3}`]'\n          v-else-if=\"entity.type === 'subscriber'\"\n          :key=\"`subs${entity.id}`\"\n          :value=\"subscribers[entity.index]\"\n          @input=\"(val) => { inputSubscriber(entity.index, val) }\"\n          :status=\"subscribersStatuses[entity.index]\"\n          :subscribed=\"subscribersConnectivityStatuses[entity.index]\"\n          :messages=\"subscribersMessages[entity.index]\"\n          :version=\"activeClient.config.protocolVersion\"\n          @remove=\"removeSubscriber(entity.index)\"\n          @subscribe=\"subscribeMessageHandler(activeClient.id, entity.index)\"\n          @unsubscribe=\"unsubscribeMessageHandler(activeClient.id, entity.index)\"\n          @play=\"playSubscriberHandler(entity.index)\"\n          @pause=\"pauseSubscriberHandler(entity.index)\"\n          @clear=\"clearMessagesHandler(entity.index)\"\n          @action:send=\"sendFromSubscriberHandler\"\n        />\n        <unresolved\n          :class='[`col-xl-${entities.length < 4 ? 12 / entities.length : 3}`]'\n          v-else-if=\"entity.type === 'unresolved'\"\n          :key=\"`unresolved${index}`\"\n          :messages=\"notResolvedMessages\"\n          @clear=\"clearUnresolvedMessages\"\n        />\n        <logs\n          :class='[`col-xl-${entities.length < 4 ? 12 / entities.length : 3}`]'\n          v-else-if=\"entity.type === 'logs'\"\n          :key=\"`subs${index}`\"\n          :logs=\"activeClient.logs\"\n          @clear=\"clearLogs\"\n        />\n      </template>\n    </div>\n    <div v-else-if=\"!entities.length\" class=\"text-center q-mt-lg text-grey-9 text-weight-bold absolute\" style=\"font-size: 2.5rem; top: 50px; bottom: 0; left: 0; right: 0;\">No active entities</div>\n    <div v-else-if=\"!statuses[activeClient.id] && !logsModel && !entities.length\" class=\"text-center q-mt-lg text-grey-9 text-weight-bold absolute\" style=\"font-size: 2.5rem; top: 50px; bottom: 0; left: 0; right: 0;\">\n      <div>Сlient is disconnected</div>\n      <div class=\"q-mt-sm\" style=\"font-size: 1.3rem\">You can <q-btn dense color=\"grey-9\" icon=\"mdi-script\" label=\"activate logs\" @click=\"changeLogsStatus(true)\" /> for more information</div>\n    </div>\n  </div>\n</template>\n\n<style lang=\"stylus\">\n  .q-textarea--fix\n    &.q-textarea.q-field--labeled textarea.q-field__native\n      min-height 27px\n  .client__item:last-child\n    margin-bottom 16px\n  .client__wrapper\n    position absolute\n    top 50px\n    bottom 0\n    left 0\n    right 0\n    overflow auto\n</style>\n\n<script>\nimport mqtt from '../boot/async-mqtt.js'\nimport merge from 'lodash/merge'\nimport cloneDeep from 'lodash/cloneDeep'\nimport isNil from 'lodash/isNil'\nimport get from 'lodash/get'\nimport debounce from 'lodash/debounce'\nimport { LocalStorage, openURL } from 'quasar'\nimport animate from '../mixins/animate'\nimport FlespiTopic from './FlespiTopicConfigurator.vue'\nimport Subscriber from './Subscriber.vue'\nimport Publisher from './Publisher.vue'\nimport Unresolved from './Unresolved.vue'\nimport Logs from './Logs.vue'\nimport PublisherModal from './PublisherModal.vue'\nimport { version } from '../../package.json'\nimport validateEntities from '../mixins/validateEntities.js'\nimport { defaultSettings, defaultSubscriber, defaultPublisher } from '../mixins/defaults.js'\nimport jsonTreeByMessages from '../mixins/jsonTreeByMessages.js'\n\nlet\n  makeExportClients = (clients) => {\n    return Object.keys(clients).map(clientId => {\n      let client = clients[clientId]\n      return {\n        status: client.status,\n        config: client.config,\n        publishers: client.publishers,\n        subscribers: client.subscribers,\n        entities: client.entities.filter(entity => entity.type !== 'unresolved'),\n        subscribersStatuses: client.subscribersStatuses,\n        subscribersConnectivityStatuses: client.subscribersConnectivityStatuses\n      }\n    })\n  },\n  saveClientsToLocalStorage = debounce((clients) => {\n    LocalStorage.set(MQTT_BOARD_LOCALSTORAGE_NAME, makeExportClients(clients))\n  }, 500, { trailing: true })\n\nconst\n  MQTT_BOARD_LOCALSTORAGE_NAME = 'clients',\n  CLIENT_STATUS_ACTIVE = true,\n  CLIENT_STATUS_INACTIVE = false,\n  CLIENT_STATUS_USER_INACTIVE = null\n\nexport default {\n  name: 'MqttClient',\n  props: {\n    initSettings: {\n      type: Object\n    },\n    whiteLabel: {\n      type: String,\n      default: ''\n    },\n    useLocalStorage: {\n      type: Boolean,\n      default: true\n    },\n    needInitNewClient: {\n      type: Boolean,\n      default: false\n    },\n    secure: {\n      type: Boolean,\n      default: true\n    },\n    color: {\n      type: String,\n      default: 'grey-9'\n    },\n    accentColor: {\n      type: String,\n      default: 'light-blue-7'\n    },\n    initEntities: {\n      type: Array,\n      default () {\n        return [\n          {\n            type: 'subscriber',\n            settings: cloneDeep(defaultSubscriber)\n          },\n          {\n            type: 'publisher',\n            settings: cloneDeep(defaultPublisher)\n          }\n        ]\n      },\n      validator (entities) {\n        return entities.reduce((result, entity, index) => {\n          if (!validateEntities.methods.validateEntity(entity)) {\n            return result && false\n          }\n          return result && true\n        }, true)\n      }\n    },\n    configuredClients: {\n      type: Array,\n      default () { return [] },\n      validator (clients) {\n        let result = true\n        clients.forEach(client => {\n          if (!client.config || !client.entities || !client.publishers || !client.subscribers) {\n            result = false\n            return false\n          }\n          result = result && validateEntities.methods.validateSettings(client.config)\n          client.entities.forEach(entity => {\n            result = result && validateEntities.methods.validateEntityRecord(entity)\n          })\n          client.publishers.forEach(publisher => {\n            result = result && validateEntities.methods.validatePublisher(publisher)\n          })\n          client.subscribers.forEach(subscriber => {\n            result = result && validateEntities.methods.validateSubscriber(subscriber)\n          })\n        })\n        return result\n      }\n    }\n  },\n  data () {\n    return {\n      version: version,\n      currentSettings: cloneDeep(merge({}, defaultSettings, this.initSettings)),\n      prevSettings: null,\n      clients: {},\n      statuses: {},\n      activeClient: null,\n      entities: [],\n      publishers: [],\n      subscribers: [],\n      subscribersStatuses: [false],\n      subscribersConnectivityStatuses: [false],\n      subscribersMessages: [[]],\n      subscribersMessagesBuffer: [[]],\n      connectUserProperty: {\n        value: '',\n        name: ''\n      },\n      willConnectUserProperty: {\n        value: '',\n        name: ''\n      },\n      settingsModalModel: false,\n      activeClientSettings: null,\n      renderInterval: 0,\n      messagesLimitCount: 3000,\n      notResolvedMessages: [],\n      isNeedScroll: false,\n      isInited: false,\n      republishMessage: null\n    }\n  },\n  computed: {\n    isCurrentSettingsValid () {\n      let settings = this.currentSettings\n      return this.validateSettings(this.currentSettings) && !!this.secure && !(settings.host.indexOf('ws:') === 0)\n    },\n    logsModel () {\n      return !!this.activeClient && !!this.entities.filter(entity => entity.type === 'logs').length\n    },\n    unresolvedModel () {\n      return !!this.activeClient && !!this.entities.filter(entity => entity.type === 'unresolved').length\n    }\n  },\n  methods: {\n    isNil,\n    openURL: openURL,\n    /* settings modal handlers start */\n    showSettingsModalHandler () {\n      this.prevSettings = cloneDeep(this.currentSettings)\n    },\n    revertSettings () {\n      this.clearCurrentSettings()\n      this.prevSettings = null\n    },\n    clearCurrentSettings () {\n      this.currentSettings = cloneDeep(merge({}, defaultSettings, this.initSettings))\n      this.currentSettings.clientId = `mqtt-board-${Math.random().toString(16).substr(2, 8)}`\n      this.activeClientSettings = null\n    },\n    saveSettingsHandler () {\n      this.prevSettings = null\n      this.createClient(this.activeClientSettings)\n      this.settingsModalModel = false\n    },\n    addUserProperty () {\n      if (!this.currentSettings.properties.userProperties) {\n        this.currentSettings.properties.userProperties = {}\n      }\n      this.currentSettings.properties.userProperties[this.connectUserProperty.name] = this.connectUserProperty.value\n      this.connectUserProperty = {\n        value: '',\n        name: ''\n      }\n    },\n    addWillUserProperty () {\n      if (!this.currentSettings.will.properties.userProperties) {\n        this.currentSettings.will.properties.userProperties = {}\n      }\n      this.currentSettings.will.properties.userProperties[this.willConnectUserProperty.name] = this.willConnectUserProperty.value\n      this.willConnectUserProperty = {\n        value: '',\n        name: ''\n      }\n    },\n    removeConnectUserProperty (name) {\n      this.$delete(this.currentSettings.properties.userProperties, name)\n      if (!Object.keys(this.currentSettings.properties.userProperties).length) {\n        this.currentSettings.properties.userProperties = null\n      }\n    },\n    removeWillConnectUserProperty (name) {\n      this.$delete(this.currentSettings.will.properties.userProperties, name)\n      if (!Object.keys(this.currentSettings.will.properties.userProperties).length) {\n        this.currentSettings.will.properties.userProperties = null\n      }\n    },\n    /* settings modal handlers end */\n    /* client logic start */\n    clearObject (obj) {\n      return Object.keys(obj).reduce((result, key) => {\n        let value = obj[key]\n        if (value instanceof Object) {\n          value = this.clearObject(value)\n          if (!Object.keys(value).length) {\n            value = undefined\n          }\n        }\n        if (value !== undefined && value !== null) {\n          result[key] = value\n        }\n        return result\n      }, {})\n    },\n    resolveSubscription (packet, subscription) {\n      let subscriptionIdentifiers = get(subscription, 'options.properties.subscriptionIdentifier', undefined),\n        packetSubIdentifiers = get(packet, 'properties.subscriptionIdentifier', undefined)\n      if (\n        packetSubIdentifiers && subscriptionIdentifiers &&\n        (\n          (typeof packetSubIdentifiers === 'number' && packetSubIdentifiers === subscriptionIdentifiers) ||\n          (Array.isArray(packetSubIdentifiers) && packetSubIdentifiers.includes(subscriptionIdentifiers))\n        )\n      ) {\n        return true\n      }\n      /* check topic */\n      if (this.resolveTopics(packet.topic, subscription.topic)) {\n        return true\n      }\n      return false\n    },\n    resolveSubscriptions (packet, subscriptions, statuses) {\n      return subscriptions.reduce((res, subscription, index) => {\n        if (statuses[index] && this.resolveSubscription(packet, subscription)) {\n          res.push(index)\n        }\n        return res\n      }, [])\n    },\n    getSharedTopicFilter (topic) {\n      return topic.replace(/^\\$share\\/[^/]+\\//, '')\n    },\n    resolveTopics (topic, subTopic) {\n      if (subTopic.indexOf('$share') === 0) {\n        subTopic = this.getSharedTopicFilter(subTopic)\n      }\n      let subTopicPath = subTopic.split('/'),\n        topicPath = topic.split('/')\n\n      if (topicPath.length === subTopicPath.length || subTopicPath[subTopicPath.length - 1] === '#') {\n        return subTopicPath.reduce((result, currentPath, index) => {\n          if (currentPath === '#' || currentPath === '+') {\n            return result && true\n          }\n          return result && currentPath === topicPath[index]\n        }, true)\n      } else {\n        return false\n      }\n    },\n    errorHandler (key, e, needShow) {\n      let clientObj = this.clients[key]\n      clientObj.logs.push({ type: 'error', data: { error: e }, timestamp: Date.now() })\n      if (needShow) {\n        this.showError(e)\n      }\n    },\n    showError (e) {\n      this.$q.notify({\n        message: `<div class=\"text-center\" style=\"font-size: 1.2rem;\">${e.message}</div>`,\n        html: true,\n        color: 'negative',\n        icon: 'mdi-alert-outline',\n        timeout: 2000\n      })\n    },\n    saveClients () {\n      if (!this.isInited) { return false }\n      this.$emit('change', makeExportClients(this.clients))\n      if (this.useLocalStorage) {\n        saveClientsToLocalStorage(this.clients)\n      }\n    },\n    createConnectPacket (config) {\n      config = this.clearObject(config)\n      if (config.protocolVersion !== 5) {\n        delete config.properties\n        if (config.will) {\n          delete config.will.properties\n        }\n      }\n      if (config.will && !config.will.topic && !config.will.payload) {\n        delete config.will\n      }\n      return config\n    },\n    setClientStatus (key, status) {\n      if (!this.clients[key]) { return false }\n      this.$set(this.statuses, key, status)\n      this.$set(this.clients[key], 'status', status)\n    },\n    messageProcessing (packet, clientId) {\n      packet.payload = packet.payload.toString()\n      try {\n        packet.payload = JSON.parse(packet.payload)\n      } catch (e) {}\n      let clientObj = this.clients[clientId]\n      /* if subscribersStatuses contains true or paused statuses */\n      if (clientObj.subscribersStatuses.length && clientObj.subscribersStatuses.filter(status => !!status).length) {\n        let activeSubscriptionsIndexes = this.resolveSubscriptions(packet, clientObj.subscribers, clientObj.subscribersStatuses),\n          isResolved = !!activeSubscriptionsIndexes.length\n        if (isResolved) {\n          activeSubscriptionsIndexes.forEach((index) => {\n            if (clientObj.subscribersStatuses[index] === true) {\n              clientObj.subscribersMessagesBuffer[index].push(packet)\n            } else if (clientObj.subscribersStatuses[index] === 'paused') {\n              if (clientObj.subscribers[index].missedMessages === undefined) {\n                clientObj.subscribers[index].missedMessages = 0\n              }\n              clientObj.subscribers[index].missedMessages++\n            }\n          })\n        } else {\n          if (!clientObj.notResolvedFlagInit) {\n            this.$set(clientObj, 'notResolvedFlagInit', true)\n          }\n          clientObj.notResolvedMessages.push(packet)\n        }\n      } else {\n        clientObj.subscribers.filter((sub, index) => {\n          if (this.resolveSubscription(packet, sub) && !clientObj.subscribersConnectivityStatuses[index]) {\n            if (!clientObj.notResolvedFlagInit) {\n              this.$set(clientObj, 'notResolvedFlagInit', true)\n            }\n            clientObj.notResolvedMessages.push(packet)\n          }\n        })\n      }\n    },\n    initClient (key, config) {\n      let clientObj = this.clients[key]\n      let endHandler = () => {\n        this.setClientStatus(key, CLIENT_STATUS_INACTIVE)\n      }\n      let client = mqtt.connect(config.host, config)\n\n      /* resubscribe to exists topics */\n      client.on('connect', (connack) => {\n        let currentStatuses = clientObj.subscribersStatuses,\n          subscribers = clientObj.subscribers,\n          /* flespi feature */\n          existedSubscriptionsInSession = connack.properties && connack.properties.userProperties && connack.properties.userProperties.subscriptions ? JSON.parse(connack.properties.userProperties.subscriptions) : []\n        subscribers.forEach((subscriber, index) => {\n          let status = currentStatuses[index],\n            exitedSubscriptionIndex = existedSubscriptionsInSession.findIndex(subscription => subscription.topic === subscriber.topic),\n            isSubscriptionExited = exitedSubscriptionIndex !== -1\n          if (isSubscriptionExited && !status) {\n            this.$set(currentStatuses, index, true)\n          } else if (!isSubscriptionExited && status) {\n            if (subscriber.mode === 0) {\n              clientObj.messages[index].splice(0, clientObj.messages[index].length)\n            } else {\n              let tree = clientObj.messages[index]\n              let treeKeys = Object.keys(tree)\n              treeKeys.forEach(key => {\n                this.$delete(tree, key)\n              })\n            }\n            clientObj.subscribersMessagesBuffer[index] = []\n            this.subscribe(key, index)\n          }\n          if (isSubscriptionExited) {\n            existedSubscriptionsInSession.splice(exitedSubscriptionIndex, 1)\n          }\n        })\n        /* restore subscriptions by broker */\n        existedSubscriptionsInSession.forEach(subscription => {\n          this.addSubscriber(key)\n          let id = subscribers.length - 1,\n            subscriber = subscribers[id]\n          // update subscriber options by subscription\n          let options = {\n            nl: subscription.no_local,\n            rap: subscription.rap,\n            rh: subscription.retain_handling,\n            qos: subscription.qos,\n            properties: {}\n          }\n          if (subscription.subscription_id) {\n            options.subscriptionIdentifier = subscription.subscription_id\n          }\n          this.$set(subscriber, 'options', options)\n          this.$set(subscriber, 'topic', subscription.topic)\n          this.$set(currentStatuses, id, true)\n          let grants = [{\n            nl: subscription.no_local,\n            rap: subscription.rap,\n            rh: subscription.retain_handling,\n            qos: subscription.qos,\n            topic: subscription.topic\n          }]\n          this.$nextTick(() => { clientObj.logs.push({ type: 'subscribe', data: { grants, restored: true }, timestamp: Date.now() }) })\n        })\n      })\n      client.on('connect', () => {\n        this.setClientStatus(key, CLIENT_STATUS_ACTIVE)\n      })\n      client.on('connect', (connack) => {\n        /* client connect logs push */\n        clientObj.logs.push({ type: 'connect', data: { ...connack }, timestamp: Date.now() })\n      })\n      client.once('connect', (connack) => {\n        this.$set(clientObj, 'cid', this.getCid(connack))\n        this.$set(clientObj, 'inited', true)\n        this.activateRender()\n        let messageBuffer = []\n        clientObj.processTimer = setInterval(() => {\n          messageBuffer.forEach((message) => { this.messageProcessing(message, key) })\n          messageBuffer = []\n        }, 500)\n        client.on('message', (topic, message, packet) => {\n          messageBuffer.push(packet)\n        })\n      })\n      client.on('error', (error) => {\n        this.errorHandler(key, error, false)\n      })\n      client.on('disconnect', (closePacket) => {\n        if (closePacket.reasonCode === 143) {\n          clientObj.subscribersStatuses.forEach((status, index) => {\n            if (status) {\n              this.$delete(clientObj.client._client._resubscribeTopics, clientObj.subscribers[index].topic)\n              this.$set(clientObj.subscribersStatuses, index, false)\n              this.$set(clientObj.subscribersConnectivityStatuses, index, false)\n            }\n          })\n        }\n        clientObj.logs.push({ type: 'disconnect', data: { ...closePacket }, timestamp: Date.now() })\n        endHandler()\n      })\n      client.on('close', () => {\n        clientObj.logs.push({ type: 'disconnect', timestamp: Date.now() })\n        endHandler()\n      })\n      client.on('offline', () => {\n        this.$set(clientObj, 'inited', false)\n        clientObj.logs.push({ type: 'offline', timestamp: Date.now() })\n        endHandler()\n      })\n      client.on('end', () => {\n        clientObj.logs.push({ type: 'end', timestamp: Date.now() })\n        endHandler()\n      })\n      client.on('reconnect', () => {\n        this.$set(clientObj, 'inited', true)\n        clientObj.logs.push({ type: 'reconnect', timestamp: Date.now() })\n      })\n      this.$set(this.clients[key], 'client', client)\n    },\n    async createClient (index) {\n      let config = this.createConnectPacket(this.currentSettings),\n        isClientExists = typeof index === 'string' || typeof index === 'number',\n        key = isClientExists\n          ? index\n          : Object.keys(this.clients).reduce((result, id) => result > parseInt(id) ? result : parseInt(id), -1) + 1\n      /* init new client */\n      if (!this.clients[key]) {\n        let client = {}\n        client.id = key\n        client.status = false\n        this.createInitEntities(client)\n        client.logs = [{ type: 'created', data: { ...config }, timestamp: Date.now() }]\n        client.notResolvedMessages = []\n        this.clients[key] = client\n      } else {\n        let clientObj = this.clients[key]\n        if (clientObj.client) {\n          if (clientObj.processTimer) {\n            clearInterval(clientObj.processTimer)\n          }\n          await clientObj.client.end()\n          this.setClientStatus(key, CLIENT_STATUS_INACTIVE)\n        }\n        clientObj.logs.push({ type: 'updated', data: { ...config }, timestamp: Date.now() })\n      }\n      if (this.statuses[key] !== CLIENT_STATUS_USER_INACTIVE) {\n        this.initClient(key, config)\n      }\n      this.$set(this.clients[key], 'config', config)\n      this.saveClients()\n      this.clearCurrentSettings()\n    },\n    initExternalClients (savedClients) {\n      if (savedClients) {\n        savedClients.forEach(client => {\n          let key = Object.keys(this.clients).length\n          let currentClient = {}\n          currentClient.config = client.config\n          currentClient.id = key\n          currentClient.client = null\n          currentClient.status = client.status\n          currentClient.publishers = client.publishers\n          currentClient.subscribers = client.subscribers\n          currentClient.entities = client.entities\n          currentClient.messages = new Array(client.subscribers.length)\n          currentClient.subscribersMessagesBuffer = new Array(client.subscribers.length)\n          for (let i = 0; i < client.subscribers.length; i++) {\n            currentClient.messages[i] = client.subscribers[i].mode ? {} : []\n            currentClient.subscribersMessagesBuffer[i] = []\n          }\n          if (client.subscribersStatuses) {\n            currentClient.subscribersStatuses = client.subscribersStatuses\n          } else {\n            currentClient.subscribersStatuses = new Array(client.subscribers.length)\n            currentClient.subscribersStatuses.fill(false)\n          }\n          if (client.subscribersConnectivityStatuses) {\n            currentClient.subscribersConnectivityStatuses = client.subscribersConnectivityStatuses\n          } else {\n            currentClient.subscribersConnectivityStatuses = new Array(client.subscribers.length)\n            currentClient.subscribersConnectivityStatuses.fill(false)\n          }\n          currentClient.logs = [{ type: 'created', data: { ...client.config }, timestamp: Date.now() }]\n          currentClient.notResolvedMessages = []\n          this.$set(this.statuses, key, client.status)\n          this.$set(this.clients, key, currentClient)\n          if (client.status !== CLIENT_STATUS_USER_INACTIVE) {\n            this.initClient(key, this.createConnectPacket(client.config))\n          }\n        })\n      }\n    },\n    createInitEntities (client) {\n      let entities = this.initEntities\n      client.subscribers = []\n      client.publishers = []\n      client.entities = []\n      client.messages = []\n      client.subscribersMessagesBuffer = []\n      client.subscribersStatuses = []\n      client.subscribersConnectivityStatuses = []\n      entities.forEach((entity, index) => {\n        switch (entity.type) {\n          case 'subscriber': {\n            client.subscribers.push(cloneDeep(merge({}, defaultSubscriber, entity.settings)))\n            client.messages.push(entity.settings.mode ? {} : [])\n            client.subscribersMessagesBuffer.push([])\n            client.subscribersStatuses.push(false)\n            client.subscribersConnectivityStatuses.push(false)\n            client.entities.push({ type: 'subscriber', index: client.subscribers.length - 1, id: Math.random().toString(16).substr(2, 8) })\n            break\n          }\n          case 'publisher': {\n            client.publishers.push(cloneDeep(merge({}, defaultPublisher, entity.settings)))\n            client.entities.push({ type: 'publisher', index: client.publishers.length - 1, id: Math.random().toString(16).substr(2, 8) })\n            break\n          }\n          default: {\n            this.showError(new Error(`Unknown type of entity: ${entity.type}`))\n          }\n        }\n      })\n    },\n    addClientHandler () {\n      this.settingsModalModel = true\n    },\n    editClientHandler (key) {\n      this.currentSettings = cloneDeep(merge({}, defaultSettings, this.clients[key].config))\n      this.activeClientSettings = key\n      this.settingsModalModel = true\n    },\n    connectClientHandler (key) {\n      let clientObj = this.clients[key]\n      if (clientObj.client) {\n        clientObj.processTimer && clearInterval(clientObj.processTimer)\n        clientObj.client.end()\n        this.setClientStatus(key, CLIENT_STATUS_INACTIVE)\n      }\n      this.initClient(key, clientObj.config)\n      this.saveClients()\n    },\n    async disconnectClientHandler (key) {\n      let clientObj = this.clients[key]\n      clientObj.processTimer && clearInterval(clientObj.processTimer)\n      this.setClientStatus(key, CLIENT_STATUS_USER_INACTIVE)\n      await clientObj.client.end()\n      clientObj.client = null\n      this.saveClients()\n    },\n    deleteClientHandler (key) {\n      let clientObj = this.clients[key]\n      this.$q.dialog({\n        title: 'Confirm',\n        message: `Do you really want to delete client for ${clientObj.config.clientId}?`,\n        cancel: true,\n        ok: true\n      }).onOk(() => {\n        clientObj.processTimer && clearInterval(clientObj.processTimer)\n        if (clientObj.client) {\n          clientObj.client.end()\n            .then(() => {\n              this.$delete(this.statuses, key)\n              this.$delete(this.clients, key)\n              this.saveClients()\n            })\n        } else {\n          this.$delete(this.statuses, key)\n          this.$delete(this.clients, key)\n          this.saveClients()\n        }\n      })\n        .onCancel(() => {})\n    },\n    activateRender () {\n      if (!this.renderInterval) {\n        this.renderInterval = setInterval(() => {\n          Object.values(this.clients).forEach((client) => {\n            client.subscribersMessagesBuffer.forEach((messages, index) => {\n              if (!messages.length) { return false }\n              let subscriber = client.subscribers[index]\n              let savedMessages = client.messages[index]\n              if (subscriber.mode === 0) {\n                if (savedMessages) {\n                  messages = messages.splice(-this.messagesLimitCount)\n                  savedMessages.splice(savedMessages.length, 0, ...messages)\n                  savedMessages.splice(0, savedMessages.length - this.messagesLimitCount)\n                }\n                client.subscribersMessagesBuffer[index] = []\n              } else {\n                if (client.subscribersStatuses[index] && client.subscribersConnectivityStatuses[index]) {\n                  jsonTreeByMessages(messages, client.config.protocolVersion === 5 && subscriber.treeField ? subscriber.treeField : '', savedMessages)\n                  client.subscribersMessagesBuffer[index] = []\n                }\n              }\n            })\n          })\n        }, 500)\n      }\n    },\n    setActiveClient (key) {\n      let client = this.clients[key]\n      this.entities = client.entities\n      this.subscribers = client.subscribers\n      this.publishers = client.publishers\n      this.subscribersMessages = client.messages\n      this.subscribersMessagesBuffer = client.subscribersMessagesBuffer\n      this.notResolvedMessages = client.notResolvedMessages\n      this.subscribersStatuses = client.subscribersStatuses\n      this.subscribersConnectivityStatuses = client.subscribersConnectivityStatuses\n      this.activeClient = client\n    },\n    clearActiveClient () {\n      this.activeClient = null\n      this.entities = []\n      this.subscribers = []\n      this.publishers = []\n      this.subscribersMessagesBuffer = []\n      this.notResolvedMessages = []\n      this.subscribersStatuses = []\n      this.subscribersConnectivityStatuses = []\n    },\n    /* client logic end */\n    /* pub/sub logic start */\n    findEntity (obj) {\n      return this.entities.findIndex((entity) => {\n        return obj.type === entity.type && obj.index === entity.index\n      })\n    },\n    addPublisher () {\n      this.publishers.push(cloneDeep(defaultPublisher))\n      this.entities.push({ type: 'publisher', index: this.publishers.length - 1, id: Math.random().toString(16).substr(2, 8) })\n      this.saveClients()\n      this.isNeedScroll = true\n    },\n    addSubscriber (clientId) {\n      clientId = typeof clientId === 'number' || typeof clientId === 'string'\n        ? clientId\n        : this.activeClient.id\n      let clientObj = this.clients[clientId]\n      clientObj.subscribers.push(cloneDeep(defaultSubscriber))\n      clientObj.messages.push([])\n      clientObj.subscribersMessagesBuffer.push([])\n      clientObj.subscribersStatuses.push(false)\n      clientObj.subscribersConnectivityStatuses.push(false)\n      clientObj.entities.push({ type: 'subscriber', index: clientObj.subscribers.length - 1, id: Math.random().toString(16).substr(2, 8) })\n      this.saveClients()\n      if (this.activeClient) { this.isNeedScroll = true }\n    },\n    removePublisher (key) {\n      this.publishers.splice(key, 1)\n      this.entities.splice(this.findEntity({ type: 'publisher', index: key }), 1)\n      this.entities.forEach(entity => {\n        if (entity.type === 'publisher' && entity.index > key) {\n          entity.index--\n        }\n      })\n      this.saveClients()\n    },\n    async removeSubscriber (subscriberIndex) {\n      let status = this.subscribersStatuses[subscriberIndex]\n      if (status) {\n        await this.unsubscribeMessageHandler(this.activeClient.id, subscriberIndex)\n      }\n      this.subscribers.splice(subscriberIndex, 1)\n      this.clients[this.activeClient.id].subscribersStatuses.splice(subscriberIndex, 1)\n      this.subscribersConnectivityStatuses.splice(subscriberIndex, 1)\n      this.subscribersMessages.splice(subscriberIndex, 1)\n      this.entities.splice(this.findEntity({ type: 'subscriber', index: subscriberIndex }), 1)\n      this.entities.forEach(entity => {\n        if (entity.type === 'subscriber' && entity.index > subscriberIndex) {\n          entity.index--\n        }\n      })\n      this.saveClients()\n    },\n    inputSubscriber (index, val) {\n      this.$set(this.subscribers, index, val)\n      this.saveClients()\n    },\n    inputPublisher (index, val) {\n      this.$set(this.publishers, index, val)\n      this.saveClients()\n    },\n    async publishMessageHandler (clientKey, publisherIndex) {\n      await this.publishFreeMessage(this.publishers[publisherIndex])\n    },\n    async publishFreeMessage (settings) {\n      settings = this.clearObject(settings)\n      try {\n        await this.activeClient.client.publish(settings.topic, settings.payload, settings.options)\n        this.$q.notify({\n          message: `<div class=\"text-center\" style=\"font-size: 1.2rem;\">Published successfuly in topic ${settings.topic}</div>`,\n          html: true,\n          color: 'positive',\n          timeout: 700\n        })\n      } catch (e) {\n        if (this.activeClient.status) {\n          this.errorHandler(this.activeClient.id, e, true)\n        } else {\n          this.errorHandler(this.activeClient.id, new Error('Client disconnected'), true)\n        }\n      }\n    },\n    async subscribeMessageHandler (clientKey, subscriberIndex) {\n      let settings = this.clearObject(this.subscribers[subscriberIndex])\n      if (\n        this.subscribers.reduce((res, sub, index) => {\n          if (this.subscribersStatuses[index]) {\n            res.push(sub.topic)\n          }\n          return res\n        }, [])\n          .filter(topic => topic === settings.topic || settings.topic === this.getSharedTopicFilter(topic) || topic === this.getSharedTopicFilter(settings.topic)).length\n      ) {\n        this.showError(new Error('You have another subscription with same topic'))\n        return false\n      }\n      if (this.subscribersMessages && this.subscribersMessages.length) {\n        this.$set(this.subscribersMessages, subscriberIndex, settings.mode === 1 ? {} : [])\n      }\n      await this.subscribe(clientKey, subscriberIndex)\n    },\n    async subscribe (clientKey, subscriberIndex) {\n      let clientObj = this.clients[clientKey],\n        settings = this.clearObject(clientObj.subscribers[subscriberIndex])\n      try {\n        this.$set(this.clients[clientKey].subscribersStatuses, subscriberIndex, true)\n        this.$set(this.clients[clientKey].subscribersConnectivityStatuses, subscriberIndex, false)\n        let grants = await clientObj.client.subscribe(settings.topic, settings.options)\n        this.$set(this.clients[clientKey].subscribersConnectivityStatuses, subscriberIndex, true)\n        if (grants.length) {\n          clientObj.logs.push({ type: 'subscribe', data: { settings, grants }, timestamp: Date.now() })\n          if ((grants[0].qos & 0x80) > 0) {\n            throw new Error(`Subscription error ${grants[0].qos}`)\n          }\n        }\n      } catch (e) {\n        this.$set(this.clients[clientKey].subscribersStatuses, subscriberIndex, false)\n        this.$set(this.clients[clientKey].subscribersConnectivityStatuses, subscriberIndex, false)\n        if (clientObj.status) {\n          this.errorHandler(clientKey, e, true)\n        } else {\n          this.errorHandler(clientKey, new Error('Client disconnected'), true)\n        }\n      }\n      this.saveClients()\n    },\n    playSubscriberHandler (subscriberIndex) {\n      this.$set(this.subscribers[subscriberIndex], 'missedMessages', undefined)\n      this.$set(this.subscribersStatuses, subscriberIndex, true)\n    },\n    pauseSubscriberHandler (subscriberIndex) {\n      this.$set(this.subscribers[subscriberIndex], 'missedMessages', 0)\n      this.$set(this.subscribersStatuses, subscriberIndex, 'paused')\n    },\n    clearMessagesHandler (subscriberIndex) {\n      let messages = this.subscribersMessages[subscriberIndex]\n      messages.splice(0, messages.length)\n    },\n    async unsubscribeMessageHandler (clientKey, subscriberIndex) {\n      await this.unsubscribe(clientKey, subscriberIndex)\n    },\n    async unsubscribe (clientKey, subscriberIndex) {\n      let clientObj = this.clients[clientKey],\n        settings = this.clearObject(clientObj.subscribers[subscriberIndex])\n      try {\n        if (!clientObj.subscribersConnectivityStatuses[subscriberIndex]) {\n          this.$set(clientObj.subscribersConnectivityStatuses, subscriberIndex, true)\n        }\n        this.$set(clientObj.subscribersStatuses, subscriberIndex, false)\n        this.$set(clientObj.messages, subscriberIndex, settings.mode === 1 ? {} : [])\n        await clientObj.client.unsubscribe(settings.topic, { properties: settings.unsubscribeProperties })\n        clientObj.logs.push({ type: 'unsubscribe', data: this.clearObject(settings), timestamp: Date.now() })\n        this.$set(clientObj.subscribersConnectivityStatuses, subscriberIndex, false)\n      } catch (e) {\n        if (clientObj.status) {\n          this.errorHandler(clientKey, e, true)\n        } else {\n          this.errorHandler(clientKey, new Error('Client disconnected'), true)\n        }\n      }\n    },\n    sendFromSubscriberHandler (message) {\n      this.republishMessage = cloneDeep(message)\n      this.$nextTick(() => { this.$refs.publisherModal.show() })\n    },\n    /* pub/sub logic end */\n    changeLogsStatus (status) {\n      if (status) {\n        this.showLogs()\n      } else {\n        this.hideLogs()\n      }\n      this.saveClients()\n    },\n    hideLogs () {\n      let indexLogsEntity = this.entities.findIndex(entity => entity.type === 'logs')\n      this.entities.splice(indexLogsEntity, 1)\n    },\n    showLogs () {\n      this.entities.unshift({ type: 'logs' })\n      let el = this.$refs.wrapper\n      if (el) {\n        animate.start({\n          from: el.scrollLeft,\n          to: 0,\n          duration: 200,\n          apply (pos) { el.scrollLeft = pos }\n        })\n      }\n    },\n    clearLogs () {\n      let logs = this.activeClient.logs\n      logs.splice(0, logs.length)\n    },\n    changeUnresolvedStatus (status) {\n      if (status) {\n        this.showUnresolved()\n      } else {\n        this.hideUnresolved()\n      }\n    },\n    hideUnresolved () {\n      let indexLogsEntity = this.entities.findIndex(entity => entity.type === 'unresolved')\n      this.entities.splice(indexLogsEntity, 1)\n    },\n    showUnresolved () {\n      this.entities.push({ type: 'unresolved' })\n      let el = this.$refs.wrapper\n      if (el) {\n        animate.start({\n          from: el.scrollLeft,\n          to: el.offsetWidth,\n          duration: 200,\n          apply (pos) { el.scrollLeft = pos }\n        })\n      }\n    },\n    clearUnresolvedMessages () {\n      let messages = this.activeClient.notResolvedMessages\n      messages.splice(0, messages.length)\n    },\n    swipeHandler (data) {\n      let el = this.$refs.wrapper,\n        elementOffsetWidth = el && el.offsetWidth,\n        { direction } = data\n      if (el && direction === 'left') {\n        animate.start({\n          from: el.scrollLeft,\n          to: el.scrollLeft + elementOffsetWidth,\n          duration: 200,\n          apply (pos) { el.scrollLeft = pos }\n        })\n      } else if (el && direction === 'right') {\n        animate.start({\n          from: el.scrollLeft,\n          to: el.scrollLeft - elementOffsetWidth,\n          duration: 200,\n          apply (pos) { el.scrollLeft = pos }\n        })\n      }\n    },\n    flespiLoginHandler () {\n      let tokenHandler = (event) => {\n        if (typeof event.data === 'string' && ~event.data.indexOf('FlespiToken')) {\n          this.currentSettings.username = event.data\n          window.removeEventListener('message', tokenHandler)\n        }\n      }\n      window.addEventListener('message', tokenHandler)\n      this.openWindow(`https://flespi.io/login/#/providers`)\n    },\n    openWindow (url, title) {\n      title = title || 'auth'\n      let w = 500, h = 600\n      let dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left\n      let dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top\n\n      let width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width\n      let height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height\n\n      let left = ((width / 2) - (w / 2)) + dualScreenLeft\n      let top = ((height / 2) - (h / 2)) + dualScreenTop\n      let newWindow = window.open(url, title, 'toolbar=no,location=no,status=yes,resizable=yes,scrollbars=yes, width=' + w + ', height=' + h + ', top=' + top + ', left=' + left)\n\n      // Puts focus on the newWindow\n      if (window.focus) {\n        newWindow.focus()\n      }\n    },\n    getCid (connack) {\n      return get(JSON.parse(get(connack, 'properties.userProperties.token', '{}')), 'cid', null)\n    }\n  },\n  watch: {\n    subscribersStatuses (statuses) {\n      this.saveClients()\n    }\n  },\n  created () {\n    if (this.needInitNewClient && !this.configuredClients.length) {\n      this.currentSettings = cloneDeep(merge({}, defaultSettings, this.initSettings))\n      this.createClient()\n      this.setActiveClient(0)\n    }\n    if (this.configuredClients.length) {\n      this.initExternalClients(this.configuredClients)\n    } else if (this.useLocalStorage) {\n      let savedClients = LocalStorage.getItem(MQTT_BOARD_LOCALSTORAGE_NAME)\n      this.initExternalClients(savedClients)\n    }\n    this.isInited = true\n    if (window) {\n      window.addEventListener('beforeunload', () => {\n        for (let clientObjKey in this.clients) {\n          let clientObj = this.clients[clientObjKey]\n          if (clientObj.status) {\n            clientObj.processTimer && clearInterval(clientObj.processTimer)\n            clientObj.client.end()\n          }\n        }\n      })\n    }\n  },\n  destroyed () {\n    for (let clientObjKey in this.clients) {\n      let clientObj = this.clients[clientObjKey]\n      if (clientObj.status) {\n        clientObj.processTimer && clearInterval(clientObj.processTimer)\n        clientObj.client.end()\n      }\n    }\n  },\n  components: {\n    FlespiTopic, Subscriber, Publisher, Unresolved, Logs, PublisherModal\n  },\n  updated () {\n    if (this.isNeedScroll) {\n      let el = this.$refs.wrapper\n      animate.start({\n        from: el.scrollLeft,\n        to: el.scrollWidth,\n        duration: 300,\n        apply (pos) { el.scrollLeft = pos }\n      })\n      this.isNeedScroll = false\n    }\n  },\n  mixins: [ validateEntities ]\n}\n</script>\n"],"names":["require$$0","arr","_Array$isArray","i","arr2","Array","length","iter","_isIterable","Object","prototype","toString","call","_Array$from","TypeError","arrayWithoutHoles","iterableToArray","nonIterableSpread","asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","_Promise","then","fn","self","this","args","arguments","apply","err","undefined","obj","_Object$defineProperty","enumerable","configurable","writable","mqtt","require","connect","brokerURL","opts","AsyncClient","client","_client","newHandler","handleMessage","forEach","name","push","Promise","data","makeCallback","linear","t","ids","stop","id","anim","timer","cancelAnimationFrame","cancel","last","start","duration","to","from","easing","Date","uid","delta","requestAnimationFrame","handler","progress","newPos","pos","_typeof2","_Symbol","_Symbol$iterator","constructor","_typeof","module","methods","validateTopic","topic","parts","split","indexOf","schemas","payload","options","qos","retain","dup","properties","payloadFormatIndicator","messageExpiryInterval","topicAlias","responseTopic","correlationData","userProperties","contentType","mode","nl","rap","rh","subscriptionIdentifier","clientId","host","keepalive","protocolVersion","clean","username","password","sessionExpiryInterval","receiveMaximum","maximumPacketSize","topicAliasMaximum","requestResponseInformation","requestProblemInformation","authenticationMethod","authenticationData","will","willDelayInterval","type","index","validateObjectBySchema","object","schema","keys","reduce","result","objectValueType","_this","validateEntity","entity","validatePublisher","settings","validateSubscriber","validateSettings","isNil","publisher","subscriber","validateEntityRecord","defaultSettings","Math","random","substr","wsOptions","objectMode","perMessageDeflate","resubscribe","defaultSubscriber","treeField","highlight","unsubscribeProperties","defaultPublisher","jsonTreeByMessages","messages","dest","write","path","currentNesting","currentTopic","pathElement","pathIndex","Vue","set","children","valueByTreeField","JSON","stringify","clear","fill","_","nestingCount","currentPath","slice","nesting","currentChildContainers","container","getNesting","valueByPath","hasChildren","delete","getAction","message","isArray"],"mappings":"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"}